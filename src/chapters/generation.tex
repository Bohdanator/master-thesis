\chapter{Generating signed snarks}

Since the structure of snarks is generally unknown, the most efficient way of systematically generating snarks is still a brute-force approach.

\section{Chromatic index problem}

To determine the chromatic index of a cubic graph is an NP-complete problem. By extension, determining the chromatic index of a signed cubic graph is also NP-complete, because of the trivial reduction from signed chromatic index problem to unsigned chromatic index problem. Instead of designing an algorithm we decided to implement a conversion from the chromatic index problem to 3SAT and using a highly optimized SAT solver in the hope for better effectiveness.

\subsection{Conversion to 3SAT}

For any cubic signed graph $\Gamma$ we will construct a 3SAT formula $F(\Gamma)$ that is satisfiable if and only if the graph is 3-colourable. There will be three literals for each half-edge $ev$ of $\Gamma$, one for each colour from $C_3 = \{-1, 0, 1\}$. Let these be $x^{-1}_{ev}$, $x^{0}_{ev}$ and $x^{1}_{ev}$. In any evaluation of these literals that satisfy $F$ exactly one of them will be true denoting the colour of the half-edge. This will be guaranteed using three constituent formulas. Let $\Gamma = ((V, E), \sigma)$

$$F_1 = \bigwedge _{e = vw \in E} (x^{-1}_{ev} \vee x^{0}_{ev} \vee x^{1}_{ev}) \wedge (x^{-1}_{ew} \vee x^{0}_{ew} \vee x^{1}_{ew}) $$

The first formula ensures that each half-edge is coloured and is the only set containing clauses of length 3. The next formula will enforce the correctness of the colouring, restricting the colours of half edges that for one complete edge. Illegal signatures for each edge are negated using DeMorgan rules, resulting in a convenient CNF form. No edge can be coloured $0$ on one side and $1$ or $-1$ on the other ($\neg (x^{0}_{ev} \land x^{1}_{ew}) = (\neg x^{0}_{ev} \lor \neg x^{1}_{ew})$) and the colours must be the same if the edge is positive ($(\neg x^{1}_{ev} \lor \neg x^{-1}_{ew})$) and opposite if the edge is negative ($(\neg x^{1}_{ev} \lor \neg x^{1}_{ew})$).

$$F_2 = \bigwedge _{e = vw \in E} (\neg x^{0}_{ev} \vee \neg x^{1}_{ew}) \wedge (\neg x^{0}_{ev} \vee \neg x^{-1}_{ew}) \wedge (\neg x^{-1}_{ev} \lor \neg x^{\sigma (e, w)}_{ew}) \land (\neg x^{1}_{ev} \lor \neg x^{-\sigma (e, w)}_{ew}) \wedge (\dots v \rightleftarrows w \dots) $$

The first four clauses illustrate the condition from the "perspective" of $v$, they will be repeated for $w$ as well by switching instances of $v$ and $w$. Lastly we need to ensure the colouring is proper. Let $N(v) = \{(v, w) ~|~ (v,w) \in E; ~ w \in V \}$ be the set of edges incident to $v$.

$$F_3 = \bigwedge _{\substack{v \in V \\ e_1, e_2 \in N(v); ~ e_1 \neq e_2}} (\neg x^{-1}_{e_1v} \lor \neg x^{-1}_{e_2v}) \land (\neg x^{0}_{e_1v} \lor \neg x^{0}_{e_2v}) \land (\neg x^{1}_{e_1v} \lor \neg x^{1}_{e_2v}) $$

Each pair of half-edges with a common vertex has to have different colours. Note that we don't need to explicitly ensure that for each half-edge exactly one literal is true, only that at least one is true, because it is a consequence of the properness of the colouring.

\begin{theorem}
    3SAT formula $F(\Gamma) = F_1 \wedge F_2 \wedge F_3$ constructed in the way described above is satisfiable if and only if $\Gamma$ is 3-colourable.
\end{theorem}

\textit{Proof.} Follows from the construction of $F$ encapsulating all properties of a proper signed 3-colouring. \qed

\subsection{Generating algorithm}

The algorithm first finds a spanning tree and assigns positive signs to all edges in it. Edges are enumerated and the spanning tree edges will be ignored. We can now imagine that positive sign means zero and negative sign means one. The remaining edges form a binary number in this way. To obtain the next representative we simply increment this number by one. This means flipping the lowest consecutive sequence of ones and the first instance of zero. We keep reversing the sign of edges from lowest to highest until we flip a positive edge for the first time or run out of edges. If we run out of edges, we basically went from the number $2^{\frac{n}{2}+1} - 1$ to $0$. So starting with any signature that is all-positive on the spanning tree, we will have generated all equivalence classes after $2^{\frac{n}{2}+1}$ incrementations. The spanning tree, however, has to remain the same during the entire process.

\section{Implementation}

We achieved our results using the following implementation. The programming language of choice was C++ over Python due to its speed and a base of tools for graph computation. We implement a simple data structure to represent signed graphs as opposed to nauty and other optimized structures because there is little support for signed graphs "out of the box". Additionally, there is no need to optimize for the graph size. Cubic graphs and unsigned snarks are generated using snarkhunter. Our SAT solver of choice is the winner of the SAT Competition 2020\cite{SAT-Competition-2020-solvers}, kissat. It is a \say{condensed and improved reimplementation of CaDiCaL in C}.
